// KONTROL SYSTEM 2 - v0.5.8.1
//____________________________________________________
// CORE LIBRARIES
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
use { round, floor } from core::math
//____________________________________________________
// KSP LIBRARIES
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
use { CONSOLE } from ksp::console
use { CONSOLE_WINDOW } from ksp::ui
use { wait_until, sleep, notification_alert, notification_passive, Importance, yield, wait_while } from ksp::game
use { Vessel } from ksp::vessel
use { SAVE_LOAD_CONTROL } from ksp::debug

//____________________________________________________
// PERSONAL LIBRARIES
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

//____________________________________________________
// FUNCTIONS
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

//===============================
// -> Quick Save
//===============================
pub fn save_now () -> Unit = {
  SAVE_LOAD_CONTROL.quick_save()
  wait_while(fn() -> SAVE_LOAD_CONTROL.is_saving) // If waiting for completion is necessary
  CONSOLE.print_at(15, 0, "quick save done")
  yield()
}

//===============================
// -> recover vessel
//===============================
pub fn recover () -> Unit = {
  SAVE_LOAD_CONTROL.try_recover_vessel()
}

//===============================
// -> Notifications 
//===============================
//-> same as notif_orange pub fn notif (msg: string) -> Unit = notification_alert("Kontrol System", msg, Importance.None, 5)
pub fn notif_green (msg: string) -> Unit = notification_alert("Kontrol System", msg, Importance.Low, 5)
pub fn notif_orange (msg: string) -> Unit = notification_alert("Kontrol System", msg, Importance.Medium, 5)
pub fn notif_red (msg: string) -> Unit = notification_alert("Kontrol System", msg, Importance.High, 5)
pub fn popup (msg: string, duration: float = 5) -> Unit = notification_passive(msg, duration)

//===============================
// CONSOLE
//===============================
//-> to print a nice title in the console
pub fn print_title (msg: string, row: int=CONSOLE.cursor_row, cursor_back: bool=true) -> Unit = {
  // for (i in 0..msg.length) {CONSOLE.print_at (row,i,"-")}
  CONSOLE.clear_line(row)
  CONSOLE.clear_line(row+1)
  CONSOLE.print_at(row,0,msg)
  //CONSOLE.print_at(row+1,0,(0..msg.length).reduce("", fn(strike, c) -> strike + "‾"))
  for (i in 0..msg.length) {CONSOLE.print_at(row+1,i,"‾")}
  if (!cursor_back) {CONSOLE.move_cursor(row+2,0)}
}

//-> to change the cursor row in the console
pub fn skip_line (l: int) -> Unit = {
  CONSOLE.move_cursor(CONSOLE.cursor_row + l, 0)
}

//===============================
//-> end of mission to close the terminal
//===============================
pub fn end_of_mission (craft: Vessel) -> Unit = {
  CONSOLE.clear()
  craft.set_throttle(0)
  print_title("End of the mission.", CONSOLE.cursor_row, false)
  CONSOLE.print_line("Window will be closed in:")
  for (i in 0..3) {
    CONSOLE.print_at(CONSOLE.cursor_row,0, (3-i).to_string())
    sleep(1)
  }
  CONSOLE.clear()
  notif_green("Script finished")
  yield()
  CONSOLE_WINDOW.close()
}

//===============================
//-> to round a float with n digits in the decimal part
//===============================
pub sync fn f_round (f: float, n:int) -> float = round(f * 10**n)/10**n

//===============================
//-> sign of a number
//===============================
pub fn sign (f: float) -> int = {
  if (f < 0) {return -1}
  return 1
}

//===============================
//-> convert a float in a string " ... h ... '' ... ' "
//===============================
pub sync fn hms (f: float) -> string = {
  let hf = floor(f/3600)
  let hf_label = hf.to_string()
  if (hf < 10) {hf_label = "0" + hf_label}
  let mf = floor((f - hf*3600)/60)
  let mf_label = hf.to_string()
  if (mf < 10) {mf_label = "0" + mf_label}
  let sf = f - hf*3600 - mf*60
  let sf_label = hf.to_fixed(1)
  if (sf < 10) {sf_label = "0" + sf_label}

  hf_label + "h " + mf_label + "'' " + sf_label+"'"
}

//===============================
// -> Minimum of a list
//===============================
pub fn min_of_list (list: float[]) -> (min: float, idx: int) = {
  let temp_min = list[0]
  let temp_idx = 0
  for (i in 0..list.length) {
    if (list[i] < temp_min) {
      temp_min = list[i]
      temp_idx = i
    }
  }
  (min: temp_min, idx: temp_idx)
}


