// Last modification - KONTROL SYSTEM 2 - v0.5.8.5
//____________________________________________________
// CORE LIBRARIES
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
use { format } from core::str

//____________________________________________________
// KSP LIBRARIES
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
use { CONSOLE } from ksp::console
use { CONSOLE_WINDOW } from ksp::ui
use { MAINFRAME, Process, sleep, yield, current_time } from ksp::game
use { open_log_file, LogFile, MAIN_LOG, SAVE_LOAD_CONTROL } from ksp::debug
use { Vessel, DeltaVSituation, AutopilotMode, Targetable } from ksp::vessel
use { Orbit, Body } from ksp::orbit

//____________________________________________________
// PERSONAL LIBRARIES
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
use * from lib::misc
use { Stage_Info } from lib::my_structures
use * from lib::mission_logs
use * from lib::my_constants


//____________________________________________________
// FUNCTIONS
//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾


//===============================
//-> check for particular parts
//===============================

pub fn check_fairing (craft: Vessel) -> bool = craft.parts.filter_map(fn(p) -> p.fairing).length > 0
pub fn check_clamps (craft: Vessel) -> bool = craft.parts.filter_map(fn(p) -> p.launch_clamp).length > 0

//===============================
//-> Starting the script with or without target
//===============================

pub fn start_with_target (craft: Vessel, title: string, targ: Body, refresh_log: bool = true) -> Body = {
  CONSOLE.clear()
  CONSOLE_WINDOW.open()
  console_size(400,500)
  notif_green("Initialisation of the script")
  const this_mission = MAINFRAME.available_processes.filter(fn(p) -> p.is_running)[0]
  sleep(0.5)
  craft.target = targ
  sleep(0.5)
  const ship_target = craft.target.value.body.value
  CONSOLE.print_line($"Target: {ship_target.name}")

  if (refresh_log) {
    MAIN_LOG.truncate()
    log_mission(title, MAIN_LOG) 
    open_log_file("missions_list").log(this_mission.name)
  }  
    
  sleep(0.25)

  CONSOLE.clear()

  craft.autopilot.enabled = false // SAS
  craft.autopilot.mode = AutopilotMode.Autopilot

  ship_target
}

pub fn start (craft: Vessel, title: string, refresh_log: bool = true) -> Unit = {
  CONSOLE.clear()
  CONSOLE_WINDOW.open()
  console_size(400,500)
  notif_green("Initialisation of the script")
  const this_mission = MAINFRAME.available_processes.filter(fn(p) -> p.is_running)[0]
  open_log_file("missions_list").log(this_mission.name)
  sleep(0.5)

  if (refresh_log) {
    MAIN_LOG.truncate()
    log_mission(title, MAIN_LOG) 
  }
    
  sleep(0.25)

  CONSOLE.clear()

  craft.autopilot.enabled = false // SAS
  craft.autopilot.mode = AutopilotMode.Autopilot
}

pub fn go_to_orbit(craft: Vessel, targetApo: float, launcher: string) -> Unit = {
  MAINFRAME.available_processes.filter(fn(p) -> p.name == "to_orbit")[0].start(craft, [targetApo.to_string(), launcher])
  yield()
  MAINFRAME.available_processes.filter(fn(p) -> (p.name.contains("missions") && p.is_running))[0].stop()
}


// //===============================
// //-> logs GT parameters of the craft and returns it
// //===============================

pub fn launcher_parameters (craft: Vessel, launcher: string) -> (pitchAng: float, pitchVel: float) = {
  const crafts_file = open_log_file("launchers")
  const crafts_list = crafts_file.read_lines()
  let new_param = true
  let pitchAng = 0.0
  let pitchVel = 0.0
  let find_lv = false

  for (i in 0..crafts_list.length) {
    if (crafts_list[i].contains(launcher)) {
      new_param = false
      pitchAng = crafts_list[i+1].to_float().value
      pitchVel = crafts_list[i+2].to_float().value
      CONSOLE.print_line("Parameters loaded")
      find_lv = true
      break
    }
  }

  if (!find_lv) {manual_action(craft, "Launcher vehicule not found")}

  (pitchAng: pitchAng, pitchVel: pitchVel)
}

//===============================
//-> countdown
//===============================

pub fn countdown (craft: Vessel, clamps: bool = true, count: int = 3, file: LogFile = MAIN_LOG) -> Unit = {
  CONSOLE.clear_line(4)
  const lift_time = current_time() + 3
  let ignition = false
  while (current_time() < lift_time) {
    CONSOLE.print_at(4,0, $"{"Liftoff in:", 20} {(lift_time - current_time()):N1} s")
    if (!ignition && clamps && current_time() > lift_time - 1) {
      craft.staging.next()
      CONSOLE.print_at(6,0, "Ignition")
      ignition = true
    }
    yield()
  }
  craft.staging.next()
  CONSOLE.clear()
  print_title("LIFTOFF", 0, false)
  yield()
  const this_stage = Stage_Info(craft, craft.staging.current)
  const twr = this_stage.get_twr(DeltaVSituation.Altitude)
  const dv = this_stage.get_total_delta_v(DeltaVSituation.Altitude)
  
  log_mission_event(craft, "Liftoff", file)
  add_item($"Actual TWR    : {twr:N2}", "L", file)
  add_item($"Actual Delta-V: {dv:N2} m/s", "L", file)
  popup("Liftoff")
}


//===============================
//-> Launch with 2 given azimuth, selection of the good one
//===============================

pub fn launch_from_north (craft: Vessel, craft_target: Body, azimuth: float[]) -> float = {
  let angle_from_north = 90.0
  let msg = format("azimuth = {0:N1} °", angle_from_north)
  if (azimuth.length != 0) {
    let azimuthAN = azimuth[0]
    let azimuthDN = azimuth[1]

    const time_AN = craft.orbit.time_of_ascending_node(craft_target.orbit)
    const time_DN = craft.orbit.time_of_descending_node(craft_target.orbit)

    if (time_AN > time_DN) {
      angle_from_north = azimuthAN
      msg = format("azimuth = {0:N1} °", angle_from_north)
    } else {
      angle_from_north = azimuthDN
      msg = format("azimuth = {0:N1} °", angle_from_north)
    }
  }
  CONSOLE.print_line(msg)

  return angle_from_north
}